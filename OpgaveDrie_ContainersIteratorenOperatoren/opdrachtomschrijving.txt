Opdracht
Realiseer een SortedBinaryTree<T> container template, inclusief bijpassende
SortedBinaryTree<T>::iterator class. De relatieve rangschikking van elementen
wordt bepaald door de < operator van het type T.
De boom hoeft niet gebalanceerd te zijn o.i.d., dus hoef je bij het toevoegen van elementen
niet de volledige structuur te herzien zoals b.v. nodig zou kunnen zijn bij balanced trees. Bij
het verwijderen van elementen kan het wel nodig zijn om kleinschalig de structuur iets te
herzien. Het is dus potentieel mogelijk dat een instantie van zo'n boom, afhankelijk van
welke inserts en deletes er gebeuren, uit louter linker takken bestaat, wat niet echt een
ideale situatie is.
Als je met een “forward” iterator door de boom loopt dan moeten de elementen in de
gesorteerde volgorde (m.a.w. in de in-order volgorde) bezocht worden.
De verzameling van aangeboden methodes, de signatuur daarvan, en het gedrag daarvan
moet zoveel mogelijk analoog zijn aan dat van de bestaande containers uit de STL en met
name die van map<K,V> en set<V> (die zijn immers zelf RedBlackTrees).
De minimale set aan features:
- Default Constructor
- optioneel: Copy Constructor van een andere SortedBinaryTree<T>.
- Destructor
- empty()
- size() telt de elementen
- clear() verwijdert alle elementen
- insert(value) voegt een item toe (tenzij die al bestaat, anders NOP)
- erase(value) verwijdert een item (tenzij die niet bestaat, anders NOP)
- optioneel: count(value)
- een forward iterator
- optioneel: een reverse iterator
- de begin() en end()voor iteratoren
- optioneel: rbegin() en rend()
- wenselijk: find(value)
- erase(iterator)
	Voor de iterator(en) bestaat minstens:
- een ++x operator (walk forward)
- optioneel: --x operator (walk backwards)
- een const T& *x operator (dereference)
	Het is niet de bedoeling dat je via deze route de inhoud van de boom zou kunnen 
	veranderen, vandaar de 'const'.
- de == en != operator
Dat de iteratoren die je vergelijkt mischien bij verschillende bomen behoren, wat een
onzin resultaat zou opleveren, is een complicatie die je niet hoeft op te lossen.

Voetnoten
Je kan, naar eigen keuze, de boom realiseren als recursive boom, of als een front-end class
die weer een aantal SBTNodes<T>’s beheert die de eigenlijke boom vormen.
Idem, het kan handig zijn om eerst een baseclass BinaryTree<T> te definieren, met
SortedBinaryTree<T> als afgeleide daarvan (maar is misschien weer meer werk).
Als er een of meerdere iteratoren actief zijn en de structuur van een boom wordt veranderd
vanwege een insert of erase, dan kan het zijn dat een iterator opeens in limbo verwijst of
naar een element waarvan de inhoud is veranderd. Daar hoeft jouw implementatie geen
rekening mee te houden (Design by Contract legt de verantwoordelijkheid hiervoor immers
bij de “gebruiker”, lees: de applicatie).
Bijlage: Array.h